Prompt:

Project Context Summary for New Chat
1. Project Goal:
The user is working on a project to make a Unitree Go1 quadruped robot skateboard. The current method involves the robot lying prone on the skateboard and pushing itself forward with its hind legs.
2. The "Baseline" Script:
The user has provided a working Python script named push_board_hind.py. This script is our established "baseline" and has been manually tuned to work reasonably well.
3. Key Technical Solution Implemented: "Catch and Hold"
The baseline script contains a critical optimization called the "Catch and Hold" transition.
Problem: The robot's feet would drag on the ground for a moment after the final push, braking the skateboard and killing momentum.
Solution: The code intelligently "catches" the final recovery stroke of the push cycle and repurposes that time to execute a smooth, full-body ramp into the final "cruising pose" (with legs lifted). This creates a seamless transition from pushing to coasting.
4. The Next Step: Optimization
The overall goal is to use a machine learning algorithm to automatically find the best parameters for the pushing motion to maximize the distance the skateboard travels.
5. Agreed-Upon Two-Phase Plan:
We have agreed on a two-phase approach to this optimization task.
Phase 1 (Current Focus): We will first optimize five key parameters in the existing baseline script. This will test the optimization process and establish a clear performance improvement. The parameters to optimize are:
TAU_BOOST (pushing force)
Z_OFFSET_KNEE (downward pressure)
AMP_PUSH (swing amplitude)
SWING_TIME (swing speed)
PUSH_RATIO (duty cycle)
Phase 2 (Future Goal): If Phase 1 is successful, we will move on to a more complex trajectory optimization. This involves adding new "control point" parameters (hip_mid_q, knee_mid_q_offset, mid_time_ratio) to allow the algorithm to learn a more effective, curved swing path instead of the current linear one.
6. Implementation Details for Phase 1:
Fitness Function: The goal is to maximize distance. The optimization algorithm will therefore work to minimize the value of fitness = -distance_traveled.
Algorithm Choice: We will start with Bayesian Optimization because it is highly sample-efficient, which is ideal for time-consuming physical robot trials. CMA-ES is a potential alternative if Bayesian methods struggle.
Workflow: The plan is to create an external "harness" script to manage the optimization. This script will call the push_board_hind.py script with new parameters for each trial, prompt the user to input the measured distance, and feed the result back to the optimizer.
